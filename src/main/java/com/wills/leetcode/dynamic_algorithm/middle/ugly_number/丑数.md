# 是否丑数(简单)





# 是否丑数(中等)

给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

> 示例 1：
>
> 输入：n = 10
> 输出：12
> 解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
> 示例 2：
>
> 输入：n = 1
> 输出：1
> 解释：1 通常被视为丑数。



## 构建 小顶堆 法

对于这种就就要进行构建小顶堆，让小数在前，构建出来小顶堆，然后依次出堆，符合条件就返回

关键： 要进行去重，因为有些两个数字相乘是一样的，所以要在循环的最后进行去重操作

注意： 可能会存在超界的问题

```java
public int nthUglyNumber(int n) {
    // 自动排序的 队列
    PriorityQueue<Long> stack = new PriorityQueue<>();
    long res = 1;
    for (int i = 1; i < n; i++) {
        stack.offer(res * 2);
        stack.offer(res * 3);
        stack.offer(res * 5);
        res = stack.poll();
        // 每次取出队头元素，存入队头元素 * 2、队头元素 * 3、队头元素 * 5
        //但注意，像 12 这个元素，可由 4 乘 3 得到，也可由 6 乘 2 得到，所以要注意去重
        while (!stack.isEmpty() && res == stack.peek()) {
            stack.poll();
        }
    }
    return (int)res;
}
```

## 动态规划法

解决本题的关键就是 让每一位与 2 ， 3 ， 5 进行相乘，取最小的数字，放入dp数组中，等待满足循环次数等于n的条件下，直接返回dp[n] 即可。

```java
public int nthUglyNumber1(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    int p2 = 1, p3 = 1, p5 = 1;
    for (int i = 2; i <= n; i++) {
        int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;
        dp[i] = Math.min(Math.min(num2, num3), num5);
        if (dp[i] == num2) {
            p2++;
        }
        if (dp[i] == num3) {
            p3++;
        }
        if (dp[i] == num5) {
            p5++;
        }
    }
    return dp[n];
}
```