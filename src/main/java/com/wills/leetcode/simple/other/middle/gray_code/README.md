# [ 格雷编码](https://leetcode-cn.com/problems/gray-code/)<font color=orange>中等</font>

n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：
每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
第一个整数是 0
一个整数在序列中出现 不超过一次
每对 相邻 整数的二进制表示 恰好一位不同 ，且
第一个 和 最后一个 整数的二进制表示 恰好一位不同
给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

```text
示例 1：

输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同

示例 2：
输入：n = 1
输出：[0,1]

提示：
1 <= n <= 16

```



我们分析一下
2^1 - 1 = 1 的二进制是 0000 0000 0000 0001
2^16 - 1 = 65535的二进制是 1111 1111 1111 1111
找规律的问题：
0 -> 000
1 -> 001
3 -> 011
2 -> 010

6 -> 110
7 -> 111
5 -> 101
4 -> 100
由上述的列表可以看出，每一个循环都是4，且位数 >2位时会首位相同，然后做了一个镜面反射,那么我们直接写一个这种规律的算法即可，代码如下：

```java
public static List<Integer> grayCode(int n) {
    List<Integer> res = new ArrayList<>();
    res.add(0);
    if(n == 0) return res;
    while (n-- > 0) {
        int m = res.size();
        for (int i = m - 1; i >= 0; i--) {
            res.set(i, res.get(i) << 1);
            res.add(res.get(i) + 1);
        }
    }
    return res;
}
```

最后成功AC！

![image-20220108143816353](http://image.tinx.top/image-20220108143816353.png)