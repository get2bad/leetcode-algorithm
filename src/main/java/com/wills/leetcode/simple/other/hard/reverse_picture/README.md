# [翻转图像](https://leetcode-cn.com/problems/flipping-an-image/)

> 给定一个二进制矩阵 `A`，我们想先水平翻转图像，然后反转图像并返回结果。
>
> 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 `[1, 1, 0]` 的结果是 `[0, 1, 1]`。
>
> 反转图片的意思是图片中的 `0` 全部被 `1` 替换， `1` 全部被 `0` 替换。例如，反转 `[0, 1, 1]` 的结果是 `[1, 0, 0]`。
>
>  
>
> **示例 1：**
>
> ```
> 输入：[[1,1,0],[1,0,1],[0,0,0]]
> 输出：[[1,0,0],[0,1,0],[1,1,1]]
> 解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
>      然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
> ```
>
> **示例 2：**
>
> ```
> 输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
> 输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
> 解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
>      然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
> ```
>
>  
>
> **提示：**
>
> - `1 <= A.length = A[0].length <= 20`
> - `0 <= A[i][j] <= 1`



刚拿到这个题的时候，就想到，一定是要遍历这个数组，然后进行比较取反

整理整理思路，发现有个规律：

[1,0,0] -> [1,1,0] 如果交换的数字不同，那么结果和之前的不变

[1,0,1] -> [0,1,0] 如果交换的数字相同，那么结果和之前的是相反的

所以答案就出来了 **双指针法**

```java
/**
 * 步骤：
 * 1. 先 水平翻转图像  [1,1,0] -> [0,1,1]
 *  水平翻转图像，就是折半对换，然后取反
 * 2. 后 翻转图像 [0,1,1] -> [1,0,0]
 *
 * 思路：
 * 1. 遍历这个二维数组
 * 2. 使用双指针方法 （为什么不遍历 A[i].length / 2? 因为遍历这个，如果遇到了偶数的长度，结果会出错，所以还是双指针比较方便）
 * 3.因为通过观察，如果[1,0,0] -> 结果应为 [1,1,0]
 *      如果 A[i][left] == A[i][right] 的时候 和1做异或取反
 *      如果不相等 ，结果是不变的 例如 [1,0,1] -> [1,1,1]
 */
public static int[][] flipAndInvertImage(int[][] A) {
    if(A == null && A.length == 0) return null;
    int length = A.length;
    for (int i = 0; i < length; i++) {
        int left = 0,right = length -1;
        while(left < right){
            if(A[i][left] == A[i][right]){
                A[i][left] ^= 1;
                A[i][right] ^= 1;
            }
            left ++;
            right --;
        }
        // 如果 左 = 右 说明指针到了中间，将中间进行去个反就行了
        // 如果是偶数长度 不加 if会出错
        // 如果是 双 for循环形式 也要加个 左 = 右 的判断
        if(left == right){
            A[i][left] ^= 1;
        }
    }
    return A;
```

