## 24. 重塑矩阵 -> ReShape

> 在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。
>
> 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。
>
> 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。
>
> 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。
>
> 示例 1:
>
> 输入:
> nums =
> [[1,2],
> [3,4]]
> r = 1, c = 4
> 输出:
> [[1,2,3,4]]
> 解释:
> 行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
> 示例 2:
>
> 输入:
> nums =
> [[1,2],
> [3,4]]
> r = 2, c = 4
> 输出:
> [[1,2],
> [3,4]]
> 解释:
> 没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
> 注意：
>
> 给定矩阵的宽和高范围在 [1, 100]。
> 给定的 r 和 c 都是正数。

一道经典的矩阵问题，本题的目的是将原矩阵转换成一个新的矩阵，比较有意思，但是实现起来比较简单，就像整数回文一样

思路大致为：

先判断原数组的元素是否和要转换的矩阵元素数量是否相等，如果不相等就直接返回原矩阵

如果相等，就遍历循环原数组的长(length)和宽(width)的乘积，循环因子为x

那么对于原数组的映射为：

​	nums[一维] [二维]：

​			[一维]： x / width

​			[二维]： x % width

对于新矩阵的映射为(c为新矩阵的宽)：

​	res[一维] [二维]:

​		[一维]：x / c

​		[二维] :  x % c

所以答案应该为：

```java
public static int[][] matrixReshape(int[][] nums, int r, int c) {
    int length = nums.length;
    int width = nums[0].length;
    if(length * width != r * c){
        return nums;
    }
    int[][] res = new int[r][c];
    // 将数组进行转换处理
    for (int x = 0; x < length*width; x++) {
        res[x/c][x%c] = nums[x/width][x%width];
    }
    return res;
}
```

