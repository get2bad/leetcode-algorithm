# [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

 

> 示例 1：
>
> ![image-20220623154449456](http://image.tinx.top/image-20220623154449456.png)
>
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[[7,4,1],[8,5,2],[9,6,3]]
> 示例 2：
>
> ![image-20220623154503403](http://image.tinx.top/image-20220623154503403.png)
>
> 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
> 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

一开始是一点思路都没有的，想找规律，发现好像没有什么规律，比如说在某一位通过某种计算就可以算出来，好像不能一步成型，这该如何是好？

然后比较丢人的翻评论，期待别人给一些提示，发现第一条真的很精辟，就是 **先转置后翻转**，我直接恍然大悟！原来可以这么玩！

说一下思路：

1. 先遍历一下这个二维数组，第一层遍历数组的长度(因为是 n x n)，第二层遍历到第一层游标，目的是进行转置数组元素(如果不这样，会转置成功后又变回原来的样子)
2. 然后进行水平翻转，很简单，就是将 二维数组的第二维进行 len - 1 - j 处理，使用这样，发现好像结果不太对？最后研究发现，**因为是水平翻转，所以第二层要除以2才行**
3. 成功AC！

```java
// 思路： 先转置 martix[i][j] = maxtix[j][i] 然后水平翻转
public void rotate(int[][] matrix) {
    int len = matrix.length;
    // 先进行转置操作
    for (int i = 0; i < len; i++) {
        for (int j = 0; j < i; j++) {
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = tmp;
        }
    }
    // 然后进行水平翻转的操作 因为要水平翻转，所以要 除以 2
    for (int i = 0; i < len; i++) {
        for (int j = 0; j < len / 2; j++) {
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[i][len - 1 - j];
            matrix[i][len - 1 - j] = tmp;
        }
    }
}
```