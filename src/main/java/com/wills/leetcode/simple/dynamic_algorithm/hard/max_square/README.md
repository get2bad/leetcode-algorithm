# 最大正方形

在一个由'0'和'1'组成的二维矩阵内，找到只包含'1'的最大正方形，并返回其面积。 

![](http://rloqc3ngo.hd-bkt.clouddn.com/img20210409100525.png)



> **输入**： 
>
> m a tri x = 
>
> [ [" 1 "," 0 "," 1 "," 0 "," 0 "] , 
>
> [" 1 "," 0 "," 1 "," 1 "," 1 "] , 
>
> [" 1 "," 1 "," 1 "," 1 "," 1 "] ,
>
> [" 1 "," 0 "," 0 "," 1 "," 0 "] ] 
>
> **输出**：4 



![](http://rloqc3ngo.hd-bkt.clouddn.com/img20210409100627.png)



> **输入**：m a tri x = [ [" 0 "," 1 "] , [" 1 "," 0 "] ] 
>
> **输出**：1 



本题是一个动态规划题，按照上述的示例，我们可以知道，我们要找出有相同数字的最大正方形(长 = 宽)

这题让求的是由1围成的最大正方形，最容易想到的一种方式就是暴力求解。解决方式就 是如果某个位置是1，就以他为正方形左上角，然后沿着右边和下边找最大的正方形，并 且还要保证围成的正方形中所有的数字都是1。 

这种虽然容易想到但代码不太好写，并且时间复杂度也比较高。其实我们可以使用动态规划来解决。



重申一遍 动态规划 的主要思想：

1. 确定状态

   > 传入的是一个 二维数组，判断一个正方形的标准就是 遇到1，如果是左上角 左边/右边 上边都是1 那么就是个正方形，输出这个面积即可(例如 2*2)

2. 找到转移公式

   如果```matri x [i][j]```是0就没法构成正方形，所以```dp[i][j]```=0。 

   如果```matri x [i][j]```是1，说明他可以构成一个正方形，并且这个正方形的边长最小是1。 

   ​	如 果 我 们 想 求 最 大 值 ， 还 需 要 判 断 他 **左 上 角** 的 值``` dp[i -1][j -1] ```， 如 果 ```dp[i -1][j -1] ```是0，那么以坐标(i , j)为右下角的最大正方形边长就是1，如下图所示 

   ​	![](http://rloqc3ngo.hd-bkt.clouddn.com/img20210409103650.png)

   换言之就是我们要从第二行开始遍历，如果遇到左上角是0的情况，那么最终就是0，

   如果左上角的值```dp[i -1][j -1]```不是0，也就是说他也可以构成正方形，那么以坐标(i , j)为  右下角有可能可以构成一个更大的正方形。为啥说是有可能，因为如果我们要确定他能不能构成一个更大的正方形，还要往他的上边和左边找，看下下面的图。

   ![image-20210409104442526](/Users/wangshuai/Library/Application Support/typora-user-images/image-20210409104442526.png)

   ​	有可能是下面这种情况，就是左边或者上边的某一个高度小于```dp[i -1][j -1]```的值，要想构 成最大的正方形我们只能取最小的。

   ​	![](http://rloqc3ngo.hd-bkt.clouddn.com/img20210409104905.png)

   ​	也有可能是下面这种，就是左边和上边的高度都不小于```dp[i -1][j -1]```的值。

   ​	![](http://rloqc3ngo.hd-bkt.clouddn.com/img20210409104943.png)

   ​	所以我们可以得出结论，如果(i , j)是1，那么以他为右下角的最大正方形边长是 ```dp[i -1][j -1]```，上边的高度，左边的高度}这3个中最小的+1。** 

   ​	这 里 有 个 问 题 就 是 ， 如 果 (i , j) 是 1 ， 我 们 有 必 要 往 他 的 上 边 和 左 边 查 找 吗 ， 很 明 显 没 必 要，上边可以用```dp[i -1][j]```来代表，左边可以用```dp[i][j -1]```来代表。（注意这里dp[i -1] [j]并不是上边为1的高度，```dp[i -1][j]```只会小，不会大，可以想一下为什么可以代表） 

   ​	所以我们可以找出递推公式 

   ​	**如果坐标(i,j)为0，** 

   ​	```则dp[i][j]=0;```

   ​	**如果坐标(i,j)为1，**

   ​	```则dp[i][j]=min(dp[i -1][j],dp[i][j -1],dp[i -1][j -1])+1;```

3. 确定初始条件以及边界条件

   > 为了防止一些不必要的边界条件判断，我把dp数组的长和宽都增加了1



所以答案是：

```java
public static int maximalSquare(int[][] martix){
    // 长
    int len = martix.length;
    // 宽
    int wid = martix[0].length;
    // 存储结果的数组
    int[][] dp = new int[len+1][wid+1];
    // 最大长方形的宽
    int maxSize = 0;
    for (int i = 1; i <= len; i++) {
        for (int j = 1; j <= wid; j++) {
            if(martix[i - 1][j - 1] == 1){
                // 取 最小值(上面，最小值(左上角，左边)) + 1
                dp[i][j] = Math.min(dp[i - 1][j],Math.min(dp[i-1][j - 1],dp[i][j - 1])) + 1;

                maxSize = Math.max(maxSize,dp[i][j]);
            }
        }
    }
    return maxSize * maxSize;
}
```



总结：

核心思路就是： 

​	声明一个二维数组，用来存储结果

​	结果 = 最小值(上面，最小值(左上角，左边)) + 1

​	如果 结果数组遍历上面 左上角 左边都是1 那么那个值就是2

​	后面遍历，如果遇到上述的情况，那么会在上面的基础上 2+ 1 = 3

​	测试例子：

```
int[][] source = {{1,0,1,0,0},
                  {1,0,1,1,1},
                  {1,1,1,1,1},
                  {1,0,1,1,1}} ;
```

最终结果输出： (3*3) = 9

