# [91. 解码方法](https://leetcode.cn/problems/decode-ways/)

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

> 示例 1：
>
> 输入：s = "12"
> 输出：2
> 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
> 示例 2：
>
> 输入：s = "226"
> 输出：3
> 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
> 示例 3：
>
> 输入：s = "0"
> 输出：0
> 解释：没有字符映射到以 0 开头的数字。
> 含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
> 由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。

## 动态规划

思路：

1. 声明dp数组，以及将传入的字符串转化为字符数组，初始化dp数组的第一个元素为1（由于可能会出现 0116 这种字符串，所以将传入字符串追加头部字符空格，保证前导零的状况不会出现）
2. 遍历这个字符串(从1开始)
   1. 找到当前位和上一位的具体值
   2. 进行判断，如果 a 是处于 1到9之间，说明是有效的，所以当前就是上一位的结果
   3. 如果 b(当前位和上一位的叠加值)处在 10 和 26 之间，说明又出现了一个新的解决方案，所以dp[i] += dp[i - 2] (为什么不是 i - 1呢？因为我们用了 i-1位)
3. 返回 dp[len]

对于字符串 s 的任意位置 i 而言，其存在三种情况：

+ 只能由位置 i 的单独作为一个 item，设为 a，转移的前提是 a 的数值范围为 \[1,9]，转移逻辑为 f[i] = f[i - 1]。
+ 只能由位置 i 的与前一位置（i-1）共同作为一个 item，设为 b，转移的前提是 b 的数值范围为\[10,26]，转移逻辑为 f[i] = f[i - 2]。
+ 位置 i 既能作为独立 item 也能与上一位置形成 item，转移逻辑为 f[i] = f[i - 1] + f[i - 2]。

```java
public int numDecodings(String s) {
    int len = s.length();
    s = " " + s;
    char[] cs = s.toCharArray();
    int[] dp = new int[len + 1];
    dp[0] = 1;
    for (int i = 1; i <= len; i++) {
        // a : 代表「当前位置」单独形成 item
        // b : 代表「当前位置」与「前一位置」共同形成 item
        int a = cs[i] - '0', b = (cs[i - 1] - '0') * 10 + (cs[i] - '0');
        // 如果 a 属于有效值，那么 dp[i] 可以由 dp[i - 1] 转移过来
        if (1 <= a && a <= 9) dp[i] = dp[i - 1];
        // 如果 b 属于有效值，那么 dp[i] 可以由 dp[i - 2] 或者 dp[i - 1] & dp[i - 2] 转移过来
        if (10 <= b && b <= 26) dp[i] += dp[i - 2];
    }
    return dp[len];
}
```



